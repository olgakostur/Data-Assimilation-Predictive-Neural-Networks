
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>creek &#8212; creek  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="creek">
<h1>creek<a class="headerlink" href="#creek" title="Permalink to this headline">¶</a></h1>
<section id="a-dataassimilation-routine">
<h2>A dataassimilation routine<a class="headerlink" href="#a-dataassimilation-routine" title="Permalink to this headline">¶</a></h2>
<p>This package implements dataassimilation <a href="#id2"><span class="problematic" id="id1">[1]_</span></a> for <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> objects, along with hand-written matrix multiplication.</p>
<p>See :<cite>tools</cite> folder for more information.</p>
</section>
<section id="module-tools">
<span id="loaddata-py"></span><h2>loaddata.py<a class="headerlink" href="#module-tools" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">tools.loaddata.</span></span><span class="sig-name descname"><span class="pre">load_all_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_train</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_back</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_obs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Given paths to folders that contain only .npy files,
this function loads 4 datasets (from the 4 different folders) and
returns 4 numpy arrays which combine the .npy files - one numpy array
associated with each folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path_train</strong> (<em>string</em>) – </p></li>
<li><p><strong>path_test</strong> (<em>string</em>) – </p></li>
<li><p><strong>path_back</strong> (<em>string</em>) – </p></li>
<li><p><strong>path_obs</strong> (<em>string</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>one numpy array associated with each folder.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">path1</span> <span class="o">=</span> <span class="s2">&quot;data/train/&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path2</span> <span class="o">=</span> <span class="s2">&quot;data/test/&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path3</span> <span class="o">=</span> <span class="s2">&quot;data/background/&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path4</span> <span class="o">=</span> <span class="s2">&quot;data/satellite/&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">back</span><span class="p">,</span> <span class="n">obs</span> <span class="o">=</span> <span class="n">load_all_data</span><span class="p">(</span><span class="n">path1</span><span class="p">,</span> <span class="n">path2</span><span class="p">,</span> <span class="n">path3</span><span class="p">,</span> <span class="n">path4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">train</span><span class="p">)</span>
<span class="go">(1200, 871, 913)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">tools.loaddata.</span></span><span class="sig-name descname"><span class="pre">load_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Given a path, to the folder that contains only .npy files
This function returns a numpy array that merges all these files
together</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> (<em>string</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>numpy array that merges all these files</em></p></li>
<li><p><em>together</em></p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s1">&#39;data/background/&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model_data</span> <span class="o">=</span> <span class="n">load_data</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">model_data</span><span class="p">)</span>
<span class="go">(5, 871, 913)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="s1">&#39;data/satellite/&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">satellite_data</span> <span class="o">=</span> <span class="n">load_data</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">satellite_data</span><span class="p">)</span>
<span class="go">(5, 871, 913)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">tools.loaddata.</span></span><span class="sig-name descname"><span class="pre">make_sequential</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Takes as input the raw wildfire data and returns the data in a sequential
format, in the form of two arrays. The first is an array of “previous
days”, the second is an array of “next days”. This is used in the
prediction part of the project to train our models</p>
<p>The function returns two arrays, so in the case of test data, the
following is the usage:</p>
<p>train_X, train_y = make_sequential(train_data)</p>
<p>where train_data is the raw wildfire data as loaded by the loaddata
function</p>
<p><strong>*
Important to look at required data shape in data parameter below
*</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> (<em>np.array</em>) – A numpy array fo the wildfire data. In our case
this would need to be either train or test data.
<strong>*
–Required shape–
* (simulations, days, x, y)
*</strong></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>An array of all previous days. The shape of this</dt><dd><p>array will be (n_sims * (days-1))</p>
</dd>
<dt>data_y (np.array): An array of all next days. The shape of this</dt><dd><p>array will be (n_sims * (days-1))</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>data_X (np.array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">tools.loaddata.</span></span><span class="sig-name descname"><span class="pre">reshape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Given a three dimensional numpy array, this function
reshapes it into a two dimensional numpy array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arr</strong> (<em>array-like/numpy array</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>two dimensional numpy array.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_new</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">a_new</span><span class="p">)</span>
<span class="go">(2, 6)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b_new</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">b_new</span><span class="p">)</span>
<span class="go">(2, 4)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">5.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_new</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">c_new</span><span class="p">)</span>
<span class="go">(2, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">tools.loaddata.</span></span><span class="sig-name descname"><span class="pre">reshape_all_datasets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Reshapes four 3D numpy arrays into four 2D numpy arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like/numpy arrays</em>) – </p></li>
<li><p><strong>b</strong> (<em>array-like/numpy arrays</em>) – </p></li>
<li><p><strong>c</strong> (<em>array-like/numpy arrays</em>) – </p></li>
<li><p><strong>d</strong> (<em>array-like/numpy arrays</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>four 2D numpy arrays.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">5.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_new</span><span class="p">,</span> <span class="n">b_new</span><span class="p">,</span> <span class="n">c_new</span><span class="p">,</span> <span class="n">d_new</span> <span class="o">=</span> <span class="n">reshape_all_datasets</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">b_new</span><span class="p">)</span>
<span class="go">(2, 4)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-0">
<span id="dataassimilation-py"></span><h2>dataassimilation.py<a class="headerlink" href="#module-0" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">tools.dataassimilation.</span></span><span class="sig-name descname"><span class="pre">KalmanGain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Given B, H and R which are symmetric n x n matrix where
n is the number of latent space, return
kalman gain n x n matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>B</strong> (<em>np.array</em><em> or </em><em>list of lists</em>) – ‘n x n’ array</p></li>
<li><p><strong>H</strong> (<em>np.array</em><em> or </em><em>list of lists</em>) – ‘n x n’ array</p></li>
<li><p><strong>R</strong> (<em>np.array</em><em> or </em><em>list of lists</em>) – ‘n x n’ array</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array ‘n x n’ (matrix)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nNodes</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">nNodes</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">nNodes</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">nNodes</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k1</span> <span class="o">=</span> <span class="n">KalmanGain</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k1</span>
<span class="go">array([[0.5, 0. , 0. ],</span>
<span class="go">       [0. , 0.5, 0. ],</span>
<span class="go">       [0. , 0. , 0.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nNodes</span> <span class="o">=</span> <span class="mi">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">nNodes</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">nNodes</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">nNodes</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k2</span> <span class="o">=</span> <span class="n">KalmanGain</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
<span class="go">(99, 99)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">tools.dataassimilation.</span></span><span class="sig-name descname"><span class="pre">assimilate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mod_comp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sat_comp</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Given an n x n matrix of B, H, R and
model/satellite compressed data as a numpy array of size n
return the updated prediction as an array of size n</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mod_comp</strong> (<em>np.array</em>) – ‘n’ array</p></li>
<li><p><strong>sat_comp</strong> (<em>np.array</em>) – ‘n’ array</p></li>
<li><p><strong>B</strong> (<em>np.array</em><em> or </em><em>list of lists</em>) – ‘n x n’ array</p></li>
<li><p><strong>H</strong> (<em>np.array</em><em> or </em><em>list of lists</em>) – ‘n x n’ array</p></li>
<li><p><strong>R</strong> (<em>np.array</em><em> or </em><em>list of lists</em>) – ‘n x n’ array</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array of size n</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mod_comp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sat_comp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">assim</span> <span class="o">=</span> <span class="n">assimilate</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">mod_comp</span><span class="p">,</span> <span class="n">sat_comp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">assim</span>
<span class="go">array([[[0.]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">tools.dataassimilation.</span></span><span class="sig-name descname"><span class="pre">covariance_diagonal_only</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latent_space</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Given an n x n matrix and a value for latent_space
return the diagonal covariance matrix with entries
ofdiagonals as 0</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>latent_space</strong> (<em>integer</em>) – </p></li>
<li><p><strong>matrix</strong> (<em>np.array</em><em> or </em><em>list of lists</em>) – ‘n x n’ array</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array ‘n x n’ (matrix)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lat</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cov_d</span> <span class="o">=</span> <span class="n">covariance_diagonal_only</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cov_d</span>
<span class="go">array([[0.25, 0.  , 0.  , 0.  ],</span>
<span class="go">       [0.  , 0.25, 0.  , 0.  ],</span>
<span class="go">       [0.  , 0.  , 0.25, 0.  ],</span>
<span class="go">       [0.  , 0.  , 0.  , 0.25]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">tools.dataassimilation.</span></span><span class="sig-name descname"><span class="pre">mse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_pred</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Given y_obs, y_pred a numpy array of size n
return the mse between y_obs and y_pred</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y_obs</strong> (<em>np.array</em>) – ‘n’ array</p></li>
<li><p><strong>y_pred</strong> (<em>np.array</em>) – ‘n’ array</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>mse value if the dimension of input matches</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mse_val</span> <span class="o">=</span> <span class="n">mse</span><span class="p">(</span><span class="n">y_obs</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mse_val</span>
<span class="go">5.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">tools.dataassimilation.</span></span><span class="sig-name descname"><span class="pre">update_prediction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Given K and H an n x n matrix and x, y a numpy array of size n
and returns an array of size n with the updated prediction</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>np.array</em>) – ‘n’ array</p></li>
<li><p><strong>y</strong> (<em>np.array</em>) – ‘n’ array</p></li>
<li><p><strong>K</strong> (<em>np.array</em><em> or </em><em>list of lists</em>) – ‘n x n’ array</p></li>
<li><p><strong>H</strong> (<em>np.array</em><em> or </em><em>list of lists</em>) – ‘n x n’ array</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array of size n</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">updated_data</span> <span class="o">=</span> <span class="n">update_prediction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">updated_data</span>
<span class="go">array([1., 2., 3., 9., 5.])</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-1">
<span id="visualisation-py"></span><h2>visualisation.py<a class="headerlink" href="#module-1" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">tools.visualisation.</span></span><span class="sig-name descname"><span class="pre">create_slider</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simulation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'viridis'</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns a slider holoview object which allows the user to view the
progression of the wildfire spread.</p>
<p>Usage:
Simply calling the function will return the slider plot.</p>
<p><strong>*
Important to look at required data shape in data parameter below
*</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>np.array</em>) – A numpy array for the wildfire data. In our case
this would need to be either train, test,
observation or background data.
<strong>*
–Required shape–
* For train and testdata: (sims, days, x, y)
* For obs or background data: (days, x, y)
*</strong></p></li>
<li><p><strong>simulation</strong> (<em>int</em>) – Only needs to be provided if using train or test
data. It selects which simulation to run (of
which there are 300 in the train data, and 75 in
the test data). Defaulted to 0.</p></li>
<li><p><strong>cmap</strong> (<em>str</em>) – Used to specify the colour used in the wildfire plot
images. This has to be a string that matches one of
the values listed here:
<a class="reference external" href="https://matplotlib.org/3.5.1/tutorials/colors/colormaps.html">https://matplotlib.org/3.5.1/tutorials/colors/colormaps.html</a>
Default value is ‘viridis’ - the same is the matplotlib
imshow default.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>A Holomap object of the slider. Needs to be</dt><dd><p>assigned to a variable and run separatelky
in order to be displayed in Jupyter
Notebooks - see the above usage.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>hmap (HoloMap object)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">tools.visualisation.</span></span><span class="sig-name descname"><span class="pre">plot_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_arr</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>This function produces a figure of 4 subplots, one for each
day of a wildfire progression.</p>
<p>Usage:
Simply calling the function will return the slider plot. E.g:</p>
<blockquote>
<div><p>plot_data(data_arr)</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data_arr</strong> (<em>np.array</em>) – A numpy array fo the wildfire data. This
will need to be either the background or
satellite data.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">tools.visualisation.</span></span><span class="sig-name descname"><span class="pre">plot_pca_variance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pca</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_components</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Function that plots explained variance vs number of components for PCA
analysis, with annotation of explaned variance for a provided number
of components.</p>
<p>Usage:
Simply calling the function with the correct args will
return the PCA variance plot. E.g.:</p>
<blockquote>
<div><p>plot_pca_variance(pca=pca, n_components=60)</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pca</strong> (<em>PCA object</em>) – An sklearn PCA object. The result of using
sklearn.decomposition.PCA on a fitting dataset.</p></li>
<li><p><strong>n_components</strong> (<em>int</em>) – The number of components for the annotation
on the plot to show the explained variance for.
This can be a maximum of the total number of
components available in the PCA. This max can
be found using <a href="#id3"><span class="problematic" id="id4">PCA.components_</span></a>.shape[0].</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>No return variable, just the displaying of the plot.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">tools.visualisation.</span></span><span class="sig-name descname"><span class="pre">plot_simulation_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simulation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sequential</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>This function produces a figure of 4 subplots, one for each
day of a wildfire simulation. The user can specify what data set to
use (train or test), and which simulation from these datasets
to show.</p>
<p>Usage:
Simply calling the function will return the slider plot. E.g:</p>
<blockquote>
<div><p>plot_simulation_data(train_data, simulation=42)</p>
</div></blockquote>
<p><strong>*
Important to look at required data shape in data parameter below
*</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>np.array</em>) – A numpy array fo the wildfire data. In our case
this would need to be either train or test.
<strong>*
–Required shape–
* For train and testdata: (sims, days, x, y)
*</strong></p></li>
<li><p><strong>simulation</strong> (<em>int</em>) – Selects which simulation to run (of
which there are 300 in the train data, and 75 in
the test data). Defaulted to 0.</p></li>
<li><p><strong>title</strong> (<em>str</em>) – Option to add a string to augment the title of the
resultant figure</p></li>
<li><p><strong>sequential</strong> (<em>bool</em>) – Let the function know whether you are plotting
from a dataset that has a reduced amout of days.
I.e. sequential datasets that have been reshaped
for model training, or have been predicted using
our model.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">creek</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.4.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>